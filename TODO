QUESTIONS:
1. Как можем по URL да определим дали ресурсът е публичен (съотв. не изисква авторизация) или не (съотв. изисква се авторизация). Смисълът е да не се прави авторизация за ресурси, които са публични и всеки може да вид итака или иначе.

2. Каква е разликата между download и stream в URL-а?

3. Какъв е смисълът на bucket в URL-а, с който се взима медията?

4. Как клиентът подава авторизационният си ключ (хедър, cookie и пр.) - нужно е описание за извличането му (вкл. някакво декодиране, ако се прави, напр. base64 и пр.)

5. Как се валидира авторизационният ключ на клиента - в коя колекция на Монго, с каква заявка и пр.

6. Как от авторизационния ключ се извлича ID на клиента и дали това ID е Монго _id - от коя колекция на Монго, с каква заявка и пр.

(6а - опционално) Ако подаваният от клиента идентификатор на медия (id) за сваляне не е _id на обект от Монго, как се извлича въпросното _id от подаденото id?

7. Как се проверява дали даденият клиент има право на достъп до заявения ресурс (id или _id, ако са различни) - в коя колекция на Монго, с каква заявка и пр.

8. Файловете, които са public, в същата Монго колекция ли се намират, заедно с файловете, които са private, или в отделна (и коя/кои са те)?



1. за момента имаме три "бъкета" 
- private - само за тенанта
- public - не е нужно да има авторизация
- profile - мисля че и там нямаше нужда от авторизация

2.
- download - слага флаг isAttachment = true
- stream - слага флаг isAttachment = false
Ако е true се слага хедър:

headers['Content-Disposition'] = 'attachment; filename="' + encodeURIComponent(this.file.filename) + '";'

3. Не те разбрах :|

4. 
- Взима файла от базата за да чете metadata
- Ако няма metadata.access взима токена от регуеста и го валидира през допълнителния jwt ( не този към expressjs middleware а допълнително сложения )
- expressJWT пък се ползва за всички /private
- Ако има в метадатата ETag връща http status 304
- Ако няма ETag го сваля .
Всички /private (GET, POST ) както и за POST /public се прави проверка дали има хедър Authorization || authorization
Ако няма хедъри чете кукито и ако има куги СЕТВА 

Authorization = 'Bearer ' + cookie value
authorization = 'Bearer ' + cookie value

5. session колекцията

MONGODEV:SECONDARY> db.session.findOne();
{
	"_id" : ObjectId("5d09e0a52bad0f0e820ce624"),
	"tid" : ObjectId("4f72e5addf08ee10a842e573"),
	"sid" : "54c774b134a1e3755f252cba9f254e1ffc9e25ba8e35ebbff18e722d5dac8a7a",
	"uid" : ObjectId("507bc7d98d8c8c55b155657f"),
	"created" : 1560928421546,
	"last_ip" : "94.156.218.116",
	"origin" : "https://stage.onebox-pro.ch",
	"test" : null
}


6. В линка се подава :id което го търси в 

полето "metadata.fid" в таблица fs.files

7. Освен за metadata.fid търси и metadata.tid ( Tenant ID ) Нооо сега като гледам го търси така само за delete :D

8. Всичко е в fs.files и fs.chunks ( дефоултните на gridfs адаптора ) 

-----

10x, Ники, доста неща станаха ясни. Да уточня, че говорим само за GET - всичко по POST, PUT и DELETE си остава във вашия app.

Остават обаче такива, дето ти си ги знаеш, а аз - не :) Дотук имаме:
- Извличане на etag от хедър If-None-Match, ако има такъв.
- Извличане на token от cookie на име "medicloud_token" или, ако то липсва, от хедър Authorization (като задедно като Bearer).
- Взимане на данните и метаданните за файла от GridFS.
- Ако има meatdata.etag и съвпада (weak) с подадени от клиента, връщаме 304.
- Ако клиентът не е подал etag или не съвпада с този в базата, подаваме целия файл.

Въпроси по твоите обяснения:
- Да уточним сервирането на private file: какво от сесията трябва да съвпадне с метаданните на файла (намерен по metadata.fid) - само uid, само tid или и двете?
- Какво е значението на metadata.access и какви стойности може да има? Какво правим, ако има metadata.access и какво, ако го няма?
- Какво правим с web token, след като се сдобием с него? Валидираме ли го някак (не разбрах това за "допълнителен jwt" и тогава сигурно има друг "основен"...)?
- Как от web token стигаме до сесията на клиента, за вземем uid и tid?
- Правилно ли разбирам, че ако клиентът не е подал Authorization хедър, но е подал cookie, ние следва да му върнем Authorization хедър като Bearer с кукито?

---

secret : config.webtoken.sha_noise 
в токена има :
{
uid: user._id,
tid: user.tid,
url: origin,
environment: dev_storage + config.environment
}


И като се сетва се сетва с тези опции 
{expiresIn: config.webtoken.token_expiry}

кукито на токена се сетва с тези опции:

{
		path: '/',
		maxAge: config.webtoken.cookie_expiry
	}


6. В линка се подава :id което го търси в 
полето "metadata.fid" в таблица fs.files




Ако е private трябва и  fid и metadata.tid но се оказва че само fid е достатъчно :|
 Мааалеее
Въпрос 2:
Metadata.access явно е добавено в последствие но 
ако е :

1 - public
0 - private ( като идеята е да се счита за private ако го няма )

Въпрос 3 :
Това беше доста объркано и не мисля че за първа стъпка ни трябва или дали изобщо ще ни трябва. Но трябва да го прегледам като има време,
Въпрос 4:
Пак го гледам и пак се чудя как някой е решил че това е ок :D


Преди всички private се взима токена и се сетва в хедъра с "Bearer "+token после се ползва express-jwt което пък го чете от хедъра и логва потребителя.

Взима се файла от базата и  ако няма metadata.access  се ползва пъпросния втори JWT които пак чете токен/хедър и го валидира и ако не го валидира хвърля 401.
Ако е валиден отива на следващата проверка и ако няма metadata.access си хвърля 401 (cwl)

Ако има етаг връща 304
ако не го сваля от gridfs.




MONGODEV:SECONDARY> db.fs.files.findOne();
{
	"_id" : ObjectId("5b0bbb828dd9f5405d83c71b"),
	"filename" : "image_uploaded_from_ios.jpg",
	"contentType" : "image/jpeg",
	"length" : 33717,
	"chunkSize" : 261120,
	"uploadDate" : ISODate("2018-05-28T08:19:14.323Z"),
	"aliases" : null,
	"metadata" : {
		"ETag" : "72fa0118-9409-458a-9dc3-8edf6b3ac028",
		"fid" : ObjectId("5b0bbb828dd9f5405d83c718"),
		"tid" : ObjectId("57d93ce7077cb859674cdd63"),
		"uid" : ObjectId("57d93cc9077cb859674cdd61"),
		"bucket" : "original",
		"access" : 1
	},
	"md5" : "b49283c0cca5226e4456623b8b370f2c"
}

*/


